#include <iostream>
#include <string>
#include <complex>
#include <SFML/Graphics.hpp>
#include <unistd.h>
#include <chrono>
using namespace std;
using namespace sf;


bool fractalMath(int its, complex<float> z, complex<float> c,int ix, int iy){
    for (int i=0; i<its; i++){
        z = z*z+c;
        if (z.real()>2) return true;
    }
    return false;
}


void fractal(int xsize,int ysize,int xaxis,int yaxis,float scale, int its, Vertex point[], RenderWindow &window){
    window.clear();
    for (int iy=0; iy<ysize; iy++){
            for (int ix=0; ix<xsize; ix++){
                complex <float> z (0.0,0.0);
                complex <float> c ((ix-xaxis)/scale,(iy-yaxis)/scale);
                if (fractalMath(its,z,c,ix,iy)){
                    point[0].position=Vector2f(ix,iy);
                    window.draw(point,1,Points);
                }
            }
            if (!(iy%128)) window.display();
        }
    window.display();
}


int main()
{
    Image icon;
    icon.loadFromFile("icon.png");
    RenderWindow window(VideoMode::getFullscreenModes()[10], "SFML works!"); //RenderWindow window(VideoMode::getDesktopMode(), "SFML works!");
    //window.setVerticalSyncEnabled(true);
    window.setFramerateLimit(10);
    window.setIcon(icon.getSize().x,icon.getSize().y,icon.getPixelsPtr());
    
    
    int xsize = window.getSize().x;
    int ysize = window.getSize().y;
    int xaxis = xsize/2;
    int yaxis = ysize/2;
    int ix,iy=0;
    int its=128;
    float scale=250;
    complex z=(0,0);
    complex c=(0,0);

    bool flag=1;
    

    CircleShape shape(50);
    shape.setFillColor(Color::Green);
    Vertex point[] = {Vertex(Vector2f(0,0),Color::Magenta)};

    
    while (window.isOpen()) // void update();
    {
        Event event;
        while (window.pollEvent(event))
        {
            if (event.type == Event::Closed) window.close();
        }
        if (flag){
            auto begin = std::chrono::steady_clock::now();
            fractal(xsize,ysize,xaxis,yaxis,scale,its,point,window);
            cout << chrono::duration_cast<chrono::milliseconds>(chrono::steady_clock::now() - begin).count() << " ms\n";
            flag=0;
        }
        window.display();
    }
}

